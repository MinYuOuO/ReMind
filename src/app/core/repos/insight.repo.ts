// Purpose:
//   Encapsulates all CRUD operations for the `insight` table. This repo is the
//   main bridge between AI-generated content (ChatGPT / DeepSeek outputs) and
//   the local SQLite database. Each stored record represents one reflection,
//   reminder, or suggestion related to a contact.
//
// Table Schema (from db_init.service):
//   insight(
//     insight_id     TEXT PRIMARY KEY,
//     contact_id     TEXT NOT NULL,
//     user_id        TEXT NOT NULL,
//     insight_type   TEXT NOT NULL CHECK (insight_type IN ('pattern','reminder','suggestion')),
//     content        TEXT NOT NULL,
//     generated_at   TEXT NOT NULL,
//     relevant_until TEXT,
//     is_actionable  INTEGER NOT NULL CHECK (is_actionable IN (0,1)),
//     FOREIGN KEY (contact_id) REFERENCES contact(contact_id) ON DELETE CASCADE,
//     FOREIGN KEY (user_id) REFERENCES user(user_id) ON DELETE CASCADE
//   )
//
// Design notes:
//   - Keeps a clear separation between AI logic (in AiInsightService) and data
//     persistence (here).
//   - Uses ISO timestamps for all date fields.
//   - Fully offline-capable; persists via SqliteDbService, which auto-syncs to
//     IndexedDB on web builds.
// -----------------------------------------------------------------------------

import { Injectable } from '@angular/core';
import { SqliteDbService } from '../services/db.service';

// Enum-like string type for allowed insight categories
export type InsightType = 'pattern' | 'reminder' | 'suggestion';

/**
 * Model representing a single AI-generated insight.
 */
export interface Insight {
  insight_id: string;
  contact_id: string;
  user_id: string;
  insight_type: InsightType;
  content: string;           // The AI-generated message
  generated_at: string;      // ISO datetime
  relevant_until?: string | null; // optional expiry
  is_actionable: 0 | 1;      // 1 = actionable, 0 = informational
}

/** Helper: current ISO timestamp */
const now = () => new Date().toISOString();
/** Helper: generate unique id */
const uid = () =>
  crypto?.randomUUID ? crypto.randomUUID() : 'i-' + Math.random().toString(36).slice(2);

@Injectable({ providedIn: 'root' })
export class InsightRepo {
  constructor(private db: SqliteDbService) {}

  // ---------------------------------------------------------------------------
  // CREATE
  // ---------------------------------------------------------------------------

  /**
   * Insert a new AI-generated insight for a contact.
   *
   * @param contact_id  Contact the insight belongs to.
   * @param user_id     Local user who owns it.
   * @param type        Insight type: 'pattern', 'reminder', or 'suggestion'.
   * @param content     Text content generated by AI.
   * @param isActionable  Whether the user can act on this insight (1 or 0).
   * @param relevantUntil Optional expiry date (ISO).
   * @returns The inserted Insight record.
   */
  async create(
    contact_id: string,
    user_id: string,
    type: InsightType,
    content: string,
    isActionable: 0 | 1 = 0,
    relevantUntil: string | null = null
  ): Promise<Insight> {
    const insight_id = uid();
    const generated_at = now();

    const record: Insight = {
      insight_id,
      contact_id,
      user_id,
      insight_type: type,
      content,
      generated_at,
      relevant_until: relevantUntil,
      is_actionable: isActionable,
    };

    await this.db.run(
      `INSERT INTO insight (
         insight_id, contact_id, user_id,
         insight_type, content, generated_at,
         relevant_until, is_actionable
       ) VALUES (?,?,?,?,?,?,?,?)`,
      [
        record.insight_id,
        record.contact_id,
        record.user_id,
        record.insight_type,
        record.content,
        record.generated_at,
        record.relevant_until,
        record.is_actionable,
      ]
    );

    return record;
  }

  // ---------------------------------------------------------------------------
  // READ
  // ---------------------------------------------------------------------------

  /**
   * Fetch all insights for a specific contact.
   * Ordered by most recent first.
   */
  listByContact(contact_id: string): Promise<Insight[]> {
    return this.db.query<Insight>(
      `SELECT * FROM insight
       WHERE contact_id = ?
       ORDER BY datetime(generated_at) DESC`,
      [contact_id]
    );
  }

  /**
   * Fetch all insights for a specific user (all contacts combined).
   */
  listByUser(user_id: string): Promise<Insight[]> {
    return this.db.query<Insight>(
      `SELECT * FROM insight
       WHERE user_id = ?
       ORDER BY datetime(generated_at) DESC`,
      [user_id]
    );
  }

  /**
   * Retrieve one insight by ID.
   */
  async getById(insight_id: string): Promise<Insight | null> {
    const rows = await this.db.query<Insight>(
      `SELECT * FROM insight WHERE insight_id = ?`,
      [insight_id]
    );
    return rows[0] ?? null;
  }

  // ---------------------------------------------------------------------------
  // UPDATE
  // ---------------------------------------------------------------------------

  /**
   * Patch fields of an existing insight.
   * Only updates provided columns (no full overwrite).
   */
  async update(
    insight_id: string,
    fields: Partial<Omit<Insight, 'insight_id'>>
  ): Promise<void> {
    const setParts: string[] = [];
    const params: any[] = [];

    if (fields.insight_type !== undefined) {
      setParts.push('insight_type = ?');
      params.push(fields.insight_type);
    }
    if (fields.content !== undefined) {
      setParts.push('content = ?');
      params.push(fields.content);
    }
    if (fields.relevant_until !== undefined) {
      setParts.push('relevant_until = ?');
      params.push(fields.relevant_until);
    }
    if (fields.is_actionable !== undefined) {
      setParts.push('is_actionable = ?');
      params.push(fields.is_actionable);
    }

    if (!setParts.length) return;

    const sql = `UPDATE insight SET ${setParts.join(', ')} WHERE insight_id = ?`;
    params.push(insight_id);
    await this.db.run(sql, params);
  }

  // ---------------------------------------------------------------------------
  // DELETE
  // ---------------------------------------------------------------------------

  /**
   * Delete an insight by ID.
   */
  async delete(insight_id: string): Promise<void> {
    await this.db.run(`DELETE FROM insight WHERE insight_id = ?`, [insight_id]);
  }

  /**
   * Delete all expired insights (where relevant_until < today).
   * Useful for periodic cleanup.
   */
  async deleteExpired(): Promise<void> {
    const todayIso = now();
    await this.db.run(
      `DELETE FROM insight
       WHERE relevant_until IS NOT NULL
         AND datetime(relevant_until) < datetime(?)`,
      [todayIso]
    );
  }

  // ---------------------------------------------------------------------------
  // HELPER QUERIES
  // ---------------------------------------------------------------------------

  /**
   * Fetch only actionable insights for the given user (is_actionable = 1).
   */
  listActionable(user_id: string): Promise<Insight[]> {
    return this.db.query<Insight>(
      `SELECT * FROM insight
       WHERE user_id = ? AND is_actionable = 1
       ORDER BY datetime(generated_at) DESC`,
      [user_id]
    );
  }

  /**
   * Count insights per contact (for analytics / summary view).
   */
  async countByContact(contact_id: string): Promise<number> {
    const rows = await this.db.query<{ count: number }>(
      `SELECT COUNT(*) as count FROM insight WHERE contact_id = ?`,
      [contact_id]
    );
    return rows?.[0]?.count ?? 0;
  }
}